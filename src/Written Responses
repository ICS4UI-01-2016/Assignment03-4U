Question 1 ... Let's look for number 41 using LINEAR SEARCH:

0) 23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
   x
1) 23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
       x
2) 23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
            x
3)23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
               x
4) 23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
                    ✔
Question 1 ... Let's look for number 41 using BINARY SEARCH:

0) 23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
                           x
1) 23, 27, 30, 34, 41, 51
            x
2) 34, 41, 51 
       ✔
BINGO! 41 has been found!

Question 2 ... Let's sort numbers from least to highest .. USING BUBBLE SORT
0) 25, 30, 20, 80, 40, 60 
    x
1) 25, 30, 20, 80, 40, 60
       x
2) 25, 20, 30, 80, 40, 60 
            x  
3) 25, 20, 30, 80, 40, 60        
                x
4) 25, 20, 30, 40, 80, 60
                    x
5) 25, 20, 30, 40, 60, 80
                        x
6) 20, 25, 30, 40, 60, 80
    x
checks it again to verify everything is in ORDER
7) 20, 25, 30, 40, 60, 80
        x
8) 20, 25, 30, 40, 60, 80
            x
9) 20, 25, 30, 40, 60, 80
                x
10) 20, 25, 30, 40, 60, 80
                     x
11) 20, 25, 30, 40, 60, 80
                         ✔

Question 3 Find the max amount of switches needed for a binary search containing 7 numbers
33, 54, 21, 67, 47, 11, 53

It would take approximately 3 steps, Let's search for 53 :) as an example 

0) 33, 54, 21, 67, 47, 11, 53
               x
1) 47, 11, 53
        x
2) 53         
   ✔

Brief explanation: it takes 3 steps because binary search would take the last position of an array
which is 7 in this case and add it to the first position which is 1, we then divide it by 2 which gives us
position 4, we look at position 4 which is "67" which isn't "53". Next step we separate and look at left side of numbers. Same thing happens we add 1 and 4 which gives us 5, then divide it by 2 to get 2.5, but during
division, ints always round down meaning it would be 2 instead of 2.5. We look at position 2, which is "11" and isn't "53", so we then separate and look at right side of numbers, since we now have only 2 numbers
left in the array list, we add last position which is 2 and first which is 1 to get 3, then divide it by 2
to get 1.5 which again is 1. At that position we see "53". We have completed binary search.

Question 4 Which one is faster ? 
Selection sorting is little faster because insertion is only useful with smaller groups. 
In terms of amount of swaps, Selection is little more efficient.
Selection sorting would take a number and place it where it is suppose to be. 
That number will no longer be scanned for as it is now "sorted".
While insertion would go through every single number within a given series of numbers, 
and since this is a big series of numbers, we would have to go through the numbers we "sorted".

In the worst case, selection sort is more efficient in terms of how many swaps have occurred.
Worst case would mean that the list is sorted backwards and since we're comparing efficency, having a bigger
list of numbers results in a larger number of going through individual numbers (SWAPS). Furthermore, in selection
sort, the number that is "sorted" would no longer be scanned while for insertion if the num

Question 5:
the best Big O value notation could be is O(log n),
binary search is the most efficient in terms of Big O, since it would be O(log n), the common name is logarithmic time.
Essentially this method would divide the series of numbers by half every time rather than looking
through every number from beginning to end. When you divide a number, you're essentially cutting down
the amount of numbers you're sorting through. 


 
Question 7:
Generally, this type of algorithm would not be suited for a list of array that would consist 
of strings. That's because strings contain bunch of letters within one slot, having it match
another string would require breaking up the string into letters. Then have those letters matched.
The process itself is possible however, the efficiency isn't the greatest in this case.



          