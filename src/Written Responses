A3Q1: 

(*)  Indicates the number selected 
(✔) Indicates the correct number found 

Numbers stored in the array: 

23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96

Looking for 41 using Sequential Search:

The for loop in the program goes through each position in the array and 
tries to find the stored value. 


0) 23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
   *
1) 23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
       *
2) 23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
           *  
3) 23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
               * 
4) 23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
                   ✔
Number 41 is found!


Looking for 41 using Binary Search: 

The list of numbers is divided in half to find the desired middle number, 
the program checks to see if the number is correct(in our case 41). 

0) 23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
                           *
1) 23, 27, 30, 34, 41, 51
           * 
2) 34, 41, 51
       ✔

A3Q2:

0) 25, 30, 20, 80, 40, 60 
    *   *
All Good! 

1) 25, 30, 20, 80, 40, 60 
        !   !
Switch!

2) 25, 20, 30, 80, 40, 60 
            *   *
All Good! 

3) 20, 25, 30, 80, 40, 60 
                !   !
Switch!

4) 20, 25, 30, 40, 80, 60 
                    !   !
Switch! 

5) 20, 25, 30, 40, 60, 80 
    *   *
All Good! 

6) 20, 25, 30, 40, 60, 80 
        *   *
All Good! 
7) 20, 25, 30, 40, 60, 80 
            *   * 
All Good!

8) 20, 25, 30, 40, 60, 80
                *   * 
All Good! 

9) 20, 25, 30, 40, 60, 80
                    *   *
All Good! 

A3Q3:
 
Example: 1,4,9,8,6,5,3,8

It will take 3 comparisons 

0) 1, 4, 9, 8, 6, 5, 3, 8
            *
1) 1, 4, 9
      *
2) 1
   ✔

A3Q4: 

In comparison, election sort and insertion sort will take the same amount of comparisons. This is 
because, in the case where the array is sorted backwards, both algorithms will use the maximum number
of comparisons, which is O(n^2). Although in most cases other than the worst, insertion sort 
is faster, because it only does the number of comparisons that are needed,while selection sort 
compares every single pair of numbers.

A3Q5: 

The best Big O value would be the algorithm with 0(log n).The most common method of sorting
that has an O(log n) runtime is binary search. This is fastest because it starts searching 
effectively through the middle of the array and eliminates half the numbers each time. Binary search 
will cover the least number of spots in the array before sorting the entire thing. 


A3Q7: 

The counting sort method written has the simplified order 0(n+k). This algorithm is not as useful 
as any other general sorting methods because it is not that efficient. Counting sort also just works 
with numbers and not letters which is a major downside. But still when the counting sort does 
go through a list of numbers, it takes a while because it first has to break down the list 
and then after finding the desired number it has to rebuild the list, which is a main cause into 
why it is not so efficient. 





