A3Q1:
23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
Linear Search: 
23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
 X
23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
     X
23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
         X
23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
             X
23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
                 O
For linear search you would simply have code run through the entire 
set of elements. While is is running through the code, it is checking
the whether number within each index is 41. When 41 is found, the loop then stops.

Binary Search:
23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96

23, 27, 30, 34, 41, 51, 55 | 57, 60, 67, 72, 78, 83, 96
                              X
23, 27, 30 | 34, 41, 51, 55 
             X
                 41 | 51, 55 
                       X
                 41 
                 O
For binary search, you would first divide the entire set of elements into half, 
checking if the number is less than where the split has occurred. Now you



A3Q2:
Bubble sorting:
For bubble sorting, the numbers essentially check if one is greater than or less than another number, moving 
left to right. The numbers than switch index's if one if greater (left) than the other (right). The sorting
method has already gone through the first two numbers (25, 30) and realized that their positions are correct. 
25  30  20  80  40  60  (Starting set of numbers)

25  30  20  80  40  60  (1)  
X   X   X   X   X   X   

25  30  20  80  40  60  (2)
✔     ><    X   X   X   
    SWITCH!

25  20  30  80  40  60  (3)
✔   ✔  ✔   X   X   X

25  20  30  80  40  60  (4)
X   X  ✔     ><    X   
            SWITCH
25  20  30  40  80  60  (5)
X   X  ✔   ✔    ><
                SWITCH
25  20  30  40  60  80  (6)
X   X  ✔   ✔   ✔  ✔    
                
25  20  30  40  60  80  (7)
  ><    ✔   ✔  ✔   ✔
SWITCH
20  25  30  40  60  80  (8)
✔   ✔  ✔   ✔  ✔   ✔

(2) When the method goes through to find 30 and 20 in the incorrect positions, the method switches the two
numbers around so that the lower value (20) is found in index 1 and the larger value (30) is found in index
2.  
(3) The method than goes through next numbers, which are 30 and 80. Since both of these numbers are in the 
correct order but in the incorrect index, the method then goes to the next set of number which are 80 and 40.

(4)It then realizes that both 80 and 40 are in the incorrect order, therefore they become switches, 40 is then
in the index of 3 and 80 is found in the index of 4. 
 
(5)Then, the method looks at the last set of numbers, 80 and 60. It notices that they are in
incorrect order, therfore they become switched, making 60 have an index value of 4 and making 80 have an index value
of 5.  

(7)Lastly, the loop then goes to the front of the set of elements and runs through again. It notices that 25 and 20 are in 
the incorrect order of index, therefore they become switched.

(8) Final result 

A3Q3:
What is the number of steps it will take to find a specific number with a list containing 7 items?
EXAMPLE:
LOOKING FOR THE NUMBER 3!
2  3  4  1  5  7  6

2  3  4  1 | 5  7  6
             GET RID OF!
2  3  4  1 == NEW SET OF ELEMENTS

2  3 | 4  1 
      GET RID OF!
2  3 == NEW SET OF ELEMENTS
  
2 | 3
GET RID OF 2! FOUND 3!
    3 == Therefore 3 is in the index of 1!

Therefore the maximum number of comparisons to perform a binary search on a list containing seven items is 3! 
The answer is three because after the 3rd step, it is impossible to proceed with the same loop since the answer
is found! ADD MORE TO THE EXPLANATION!

A3Q4:
In the worst case, selection sort would be quicker than insertion sort. This is true due to the fact that the insertion
sorting method has to go through the numbers twice due to the method's way of working, swapping. 
In insertion sort, the method goes through every index even through the ones which are sorted already. 
Insertion sort is essentially doing more work that is "unnecessary" compared to 
selection sort. 

** Insertion sort can be n number of swaps depending on the amount of elements within an array, therefore insertion sort
would then take a longer time to sort compared to selection sort. Because of this reason I believe that 