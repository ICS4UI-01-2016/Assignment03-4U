A3Q1:
23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
Linear Search: 
23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
 X
23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
     X
23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
         X
23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
             X
23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96
                 O
For linear search you would simply have code run through the entire 
set of elements. While it is running through the code, it is checking
whether the number within each index is  the number 41. When 41 is found, the loop then stops!

Binary Search:
23, 27, 30, 34, 41, 51, 55, 57, 60, 67, 72, 78, 83, 96

23, 27, 30, 34, 41, 51, 55 | 57, 60, 67, 72, 78, 83, 96
                              X
23, 27, 30 | 34, 41, 51, 55 
             X
                 41 | 51, 55 
                       X
                 41 
                 O
Binary search works by essentially splitting a set of elements in half, checking which half the number is within
and getting rid of the other half. This occurs until there are no more numbers to be split and therfore,
the specific element is found.


A3Q2:
Bubble sorting:
For bubble sorting, the numbers essentially check if one is greater than or less than another number, moving 
left to right. The numbers than switch index's if one is greater (left) than the other (right). (1) The sorting
method has already gone through the first two numbers (25, 30) and realized that their positions are correct. 
0   1   2   3   4   5    (Indexes)
25  30  20  80  40  60  (Starting set of numbers)

25  30  20  80  40  60  (1)  
X   X   X   X   X   X   

25  30  20  80  40  60  (2)
?     ><    X   X   X   
    SWITCH!

25  20  30  80  40  60  (3)
?   ?  ?   X   X   X

25  20  30  80  40  60  (4)
X   X  ?     ><    X   
            SWITCH
25  20  30  40  80  60  (5)
X   X  ?   ?    ><
                SWITCH
25  20  30  40  60  80  (6)
X   X  ?   ?   ?  ?    
                
25  20  30  40  60  80  (7)
  ><    ?   ?  ?   ?
SWITCH
20  25  30  40  60  80  (8)
?   ?  ?   ?  ?   ?

(2) When the method goes through to find 30 and 20 in the incorrect positions, the method switches the two
numbers around so that the lower value (20) is found in index 1 and the larger value (30) is found in index
2.  
(3) The method than goes through next numbers, which are 30 and 80. Since both of these numbers are in the 
correct order but in the incorrect index, the method then goes to the next set of numbers which are 80 and 40.

(4)The sorting method then realizes that both 80 and 40 are in the incorrect order, therefore they become switched, 40 is then
in the index of 3 and 80 is found in the index of 4. 
 
(5)Then, the method looks at the last set of numbers, 80 and 60. It notices that they are in
incorrect order, therfore they become switched, making 60 have an index value of 4 and making 80 have an index value
of 5.  

(6 & 7)Lastly, the loop then goes to the front of the set of elements and runs through again. It notices that 25 and 20 are in 
the incorrect order of index, therefore they become switched, 20 then has an index of 0 and 25 has an index of 1.

(8) Final result 


A3Q3:
What is the number of steps it will take to find a specific number with a list containing 7 items?
EXAMPLE:
LOOKING FOR THE NUMBER 3!
2  3  4  1  5  7  6

2  3  4  1 | 5  7  6
             X  X  X -> GET RID OF!
2  3  4  1 ============ NEW SET OF ELEMENTS

2  3 | 4  1 
       X  X ----------> GET RID OF!
2  3 ================== NEW SET OF ELEMENTS
  
2 | 3
GET RID OF 2! FOUND 3!
    3 == Therefore 3 is in the index of 1!

Therefore the maximum number of comparisons to perform a binary search on a list containing seven items is 3! 
The answer is three because after the 3rd step, it is impossible to proceed with the same loop since the answer
is found! This occurs when either the number sought is the first number or if the number sought is not found within the array.


*A3Q4:
**In the worst case, selection sort would be quicker than insertion sort. This is true due to the fact that the insertion
sorting method has to go through the numbers twice due to the method's way of working, swapping. 
In insertion sort, the method goes through every index even through the ones which are sorted already. 
Insertion sort is essentially doing more work that is "unnecessary" compared to 
selection sort. ** Insertion sort can be n number of swaps depending on the amount of elements within an array, therefore insertion sort
would then take a longer time to sort compared to selection sort. Because of this reason I believe that 
*********************************************************************************************************************************************
In the worst case, both methods of sorting, insertion sort and selection sort have the same run time. This is
because both insertion sort and selection sort have a run time of O(n^2). Therefore, when an array is large and sorted backwards (worst case),
both sorting methods will have exactly the same run time! 

A3Q5:
The best Big O value for any searching algorithm is O(log n). This best algorithm example that achieves this Big O value is binary search. Binary search
has the ability to achieve this Big O value due to its sorting method. Binary search, also known as half-interval search works by essentially splitting a 
set of elements in half, searching for the number and so on until the specific element is found. This is extremely efficient due to the fact that after the binary search splits a 
set of elements in half, it doesn't have to look through an entire half and focuses on the other half (depends which half the number is specifically in).
Because binary search does this, it saves a lot of time not having to search and deal with the other half of numbers that are practically useless to the searching method. 
In essence, binary search is the best example when achieving the best Big O value of O(log n)!


A3Q6: Found within the Java Class Main file named ProgrammingExercises.java!
A3Q7: Counting sort is not as useful as any other algorithm due to the fact that it slacks efficiency! This sorting method first must find the amount
      of elements that have the same value and then store them. After this is finished, the new indexes have to add up together. Then for the final product, the 
      numbers which have added indexes together, go back and relate themselves to the first set of number's indexes and look to the added index and what ever number they 
      contain is where that specific number is sorted for the final result. (https://www.youtube.com/watch?v=zhDmVF_NdjM)
A3Q8: Found within the Java Class Main file named ProgrammingExercises.java!





